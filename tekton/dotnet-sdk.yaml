apiVersion: tekton.dev/v1beta1
kind: Task
metadata:
  name: dotnet-sdk
  labels:
    app.kubernetes.io/version: "0.1"
  annotations:
    tekton.dev/pipelines.minVersion: "0.19"
    tekton.dev/tags: dotnet, workspace
    tekton.dev/displayName: ".NET SDK"
spec:
  description: >-
    dotnet-sdk task runs a user-specified script that can use the .NET SDK.
  workspaces:
    - name: source
      mountPath: /workspace/source
      description: >-
        An optional workspace that allows to provide source code.
      optional: true
    - name: dockerconfig
      description: >-
        An optional workspace that allows providing a .docker/config.json file to access the container registry.
        The file should be placed at the root of the Workspace with name config.json or .dockerconfigjson.
      optional: true
    - name: dotnetconfig
      description: >-
        An optional workspace that allows providing common configuration for .NET Tekton tasks.
        If a 'setup' file is present, its contents get executed before running the script.
        If a 'Build.props' file is present, it will be loaded by the .NET SDK through CustomBeforeDirectoryBuildProps.
      optional: true
  params:
    - name: SCRIPT
      description: The OpenShift CLI arguments to run
      type: string
      default: "dotnet --info"
    - name: SDK_VERSION
      default: latest
      description: Tag of .NET SDK imagestream.
      type: string
    - name: DOTNET_NAMESPACE
      description: Namespace of the .NET imagestreams. Set to '$(context.taskRun.namespace)' to use the pipeline namespace.
      default: openshift
      type: string
    - name: ENV_VARS
      type: array
      description: Environment variables.
      default: []
  steps:
    - name: dotnet
      image: image-registry.openshift-image-registry.svc:5000/$(params.DOTNET_NAMESPACE)/dotnet:$(params.SDK_VERSION)
      args:
        - "--env-vars"
        - "$(params.ENV_VARS[*])"
      env:
      - name: OpenShiftInternalRegistry
        value: "image-registry.openshift-image-registry.svc:5000"
      - name: OpenShiftDotnetNamespace
        value: $(params.DOTNET_NAMESPACE)
      - name: OpenShiftCurrentNamespace
        value: $(context.taskRun.namespace)
      - name: RunningInTekton
        value: "true"
      - name: DOTNETCONFIG_DIRECTORY_BOUND
        value: $(workspaces.dotnetconfig.bound)
      - name: DOTNETCONFIG_DIRECTORY_PATH
        value: $(workspaces.dotnetconfig.path)
      script: |
        #!/usr/bin/env bash

        set -euo pipefail

        if [[ "$(workspaces.dockerconfig.bound)" == "true" ]]; then
          mkdir -p ~/.config/containers
          [[ -f "$(workspaces.dockerconfig.path)/config.json" ]] && ln -s "$(workspaces.dockerconfig.path)/config.json" ~/.config/containers/auth.json
          [[ -f "$(workspaces.dockerconfig.path)/.dockerconfigjson" ]] && ln -s "$(workspaces.dockerconfig.path)/.dockerconfigjson" ~/.config/containers/auth.json
        fi

        mkdir -p ~/src
        if [[ "$(workspaces.source.bound)" == "true" ]]; then
          cp -a "$(workspaces.source.path)/." ~/src
        fi
        cd ~/src

        parsing_flag=""
        for arg in "$@"; do
            if [[ "$arg" == "--env-vars" ]]; then
                parsing_flag="env-vars"
            elif [[ "$parsing_flag" == "env-vars" ]]; then
                export "$arg"
            fi
        done

        # Provide a convenient way to publish to the internal OpenShift registry.
        PublishProfileFullPath=/tmp/OpenShiftContainer.pubxml
        cat >"${PublishProfileFullPath}" <<'EOF'
        <Project>
          <PropertyGroup>
            <WebPublishMethod>Container</WebPublishMethod>

            <!-- Stop the RedHat.Container package from picking a base image. -->
            <UseRedHatContainerImage>false</UseRedHatContainerImage>
          </PropertyGroup>

          <Target Name="ComputeOpenShiftContainerBaseImage" BeforeTargets="ComputeContainerBaseImage">

            <Error Condition="'$(OpenShiftInternalRegistry)' == ''" Text="'OpenShiftInternalRegistry' is not set." />
            <Error Condition="'$(OpenShiftDotnetNamespace)' == ''" Text="'OpenShiftDotnetNamespace' is not set." />

            <!-- Pick the proper base image from the OpenShiftDotnetNamespace namespace. -->
            <PropertyGroup>
              <ContainerBaseImage>$(OpenShiftInternalRegistry)/$(OpenShiftDotnetNamespace)/dotnet-runtime:$(_TargetFrameworkVersionWithoutV)</ContainerBaseImage>
            </PropertyGroup>
          </Target>

          <Target Name="ComputeOpenShiftContainerConfig" BeforeTargets="ComputeContainerConfig">

            <Error Condition="'$(OpenShiftImageName)' == ''" Text="'OpenShiftImageName' is not set." />
            <Error Condition="'$(OpenShiftInternalRegistry)' == ''" Text="'OpenShiftInternalRegistry' is not set." />
            <Error Condition="'$(OpenShiftCurrentNamespace)' == ''" Text="'OpenShiftCurrentNamespace' is not set." />

            <!-- Expand OpenShiftImageName, using OpenShiftInternalRegistry and OpenShiftCurrentNamespace. -->
            <PropertyGroup Condition="$(OpenShiftImageName.IndexOf('.')) == -1 Or $(OpenShiftImageName.IndexOf('.')) &gt; $(OpenShiftImageName.IndexOf('/'))">
              <OpenShiftImageName Condition="$(OpenShiftImageName.IndexOf('/')) == -1">$(OpenShiftCurrentNamespace)/$(OpenShiftImageName)</OpenShiftImageName>
              <OpenShiftImageName>$(OpenShiftInternalRegistry)/$(OpenShiftImageName)</OpenShiftImageName>
            </PropertyGroup>

            <!-- Set SDK container tooling properties based on OpenShiftImageName. -->
            <PropertyGroup>
              <ContainerRegistry>$(OpenShiftImageName.Substring(0, $(OpenShiftImageName.IndexOf('/'))))</ContainerRegistry>
              <ContainerRepository>$(OpenShiftImageName.Substring($([MSBuild]::Add($(OpenShiftImageName.IndexOf('/')), 1))))</ContainerRepository>
              <ContainerImageTag>latest</ContainerImageTag>
              <ContainerImageTag Condition="$(ContainerRepository.Contains(':'))">$(ContainerRepository.Substring($([MSBuild]::Add($(ContainerRepository.IndexOf(':')), 1))))</ContainerImageTag>
              <ContainerRepository Condition="$(ContainerRepository.Contains(':'))">$(ContainerRepository.Substring(0, $(ContainerRepository.LastIndexOf(':'))))</ContainerRepository>
            </PropertyGroup>
          </Target>
        </Project>
        EOF

        if [[ "${DOTNETCONFIG_DIRECTORY_BOUND}" == "true" ]] && [[ -f "${DOTNETCONFIG_DIRECTORY_PATH}/setup" ]]; then
          source "${DOTNETCONFIG_DIRECTORY_PATH}/setup"
        fi

        export CustomBeforeDirectoryBuildProps="/tmp/CustomBeforeDirectoryBuildProps.props"
        cat >"${CustomBeforeDirectoryBuildProps}" <<'EOF'
        <Project>
          <PropertyGroup Condition="'$(PublishProfile)' == 'OpenShiftContainer'">
            <PublishProfileFullPath>/tmp/OpenShiftContainer.pubxml</PublishProfileFullPath>
          </PropertyGroup>

          <Import Project="$(DOTNETCONFIG_DIRECTORY_PATH)/Build.props" Condition="'$(DOTNETCONFIG_DIRECTORY_BOUND)' == 'true' And Exists('$(DOTNETCONFIG_DIRECTORY_PATH)/Build.props')" />
        </Project>
        EOF

        $(params.SCRIPT)
