apiVersion: tekton.dev/v1beta1
kind: Task
metadata:
  name: dotnet-publish-image
  labels:
    app.kubernetes.io/version: "0.1"
  annotations:
    tekton.dev/pipelines.minVersion: "0.19"
    tekton.dev/tags: dotnet, workspace
    tekton.dev/displayName: "dotnet publish image"
spec:
  description: >-
    dotnet-publish-image task builds a container image from a .NET project
    and pushes it to a container registry.
  results:
    - name: IMAGE_DIGEST
      description: Digest of the image.
    - name: IMAGE
      description: Fully qualified image name of the image.
  params:
    - name: PROJECT
      description: Path of the .NET project file.
      type: string
    - name: IMAGE_NAME
      description: |
        Name of the image repository to push. When it does not include a registry, it is pushed to the internal cluster registry.
        If no namespace is included, the current namespace is prepended to the name.
      type: string
    - name: SDK_VERSION
      default: latest
      description: Tag of .NET SDK imagestream.
      type: string
    - name: DOTNET_NAMESPACE
      description: Namespace of the .NET imagestreams. Set to '$(context.taskRun.namespace)' to use the pipeline namespace.
      default: openshift
      type: string
    - name: VERBOSITY
      description: MSBuild verbosity level. Allowed values are 'q[uiet]', 'm[inimal]', 'n[ormal]', 'd[etailed]', and 'diag[nostic]'.
      default: "minimal"
      type: string
    - name: ENV_VARS
      type: array
      description: Environment variables.
      default: []
  workspaces:
    - name: source
      mountPath: /workspace/source
    - name: dockerconfig
      description: >-
        An optional workspace that allows providing a .docker/config.json file to access the container registry.
        The file should be placed at the root of the Workspace with name config.json or .dockerconfigjson.
      optional: true
    - name: dotnetconfig
      description: >-
        An optional workspace that allows providing common configuration for .NET Tekton tasks.
        If a 'setup' file is present, its contents get executed before running the script.
        If a 'Build.props' file is present, it will be loaded by the .NET SDK through CustomBeforeDirectoryBuildProps.
      optional: true
  steps:
    - name: publish-image
      image: image-registry.openshift-image-registry.svc:5000/$(params.DOTNET_NAMESPACE)/dotnet:$(params.SDK_VERSION)
      args:
        - "--env-vars"
        - "$(params.ENV_VARS[*])"
      env:
      - name: OpenShiftInternalRegistry
        value: "image-registry.openshift-image-registry.svc:5000"
      - name: OpenShiftDotnetNamespace
        value: $(params.DOTNET_NAMESPACE)
      - name: OpenShiftCurrentNamespace
        value: $(context.taskRun.namespace)
      - name: RunningInTekton
        value: "true"
      - name: DOTNETCONFIG_DIRECTORY_BOUND
        value: $(workspaces.dotnetconfig.bound)
      - name: DOTNETCONFIG_DIRECTORY_PATH
        value: $(workspaces.dotnetconfig.path)
      script: |
        #!/usr/bin/env bash

        set -euo pipefail

        if [[ "$(workspaces.dockerconfig.bound)" == "true" ]]; then
          mkdir -p ~/.config/containers
          [[ -f "$(workspaces.dockerconfig.path)/config.json" ]] && ln -s "$(workspaces.dockerconfig.path)/config.json" ~/.config/containers/auth.json
          [[ -f "$(workspaces.dockerconfig.path)/.dockerconfigjson" ]] && ln -s "$(workspaces.dockerconfig.path)/.dockerconfigjson" ~/.config/containers/auth.json
        fi

        mkdir -p ~/src
        cp -a "$(workspaces.source.path)/." ~/src
        cd ~/src

        parsing_flag=""
        for arg in "$@"; do
            if [[ "$arg" == "--env-vars" ]]; then
                parsing_flag="env-vars"
            elif [[ "$parsing_flag" == "env-vars" ]]; then
                export "$arg"
            fi
        done

        PublishProfileFullPath=/tmp/OpenShiftContainer.pubxml
        cat >"${PublishProfileFullPath}" <<'EOF'
        <Project>
          <PropertyGroup>
            <WebPublishMethod>Container</WebPublishMethod>

            <!-- Stop the RedHat.Container package from picking a base image. -->
            <UseRedHatContainerImage>false</UseRedHatContainerImage>
          </PropertyGroup>

          <Target Name="ComputeOpenShiftContainerBaseImage" BeforeTargets="ComputeContainerBaseImage">

            <Error Condition="'$(OpenShiftInternalRegistry)' == ''" Text="'OpenShiftInternalRegistry' is not set." />
            <Error Condition="'$(OpenShiftDotnetNamespace)' == ''" Text="'OpenShiftDotnetNamespace' is not set." />

            <!-- Pick the proper base image from the OpenShiftDotnetNamespace namespace. -->
            <PropertyGroup>
              <ContainerBaseImage>$(OpenShiftInternalRegistry)/$(OpenShiftDotnetNamespace)/dotnet-runtime:$(_TargetFrameworkVersionWithoutV)</ContainerBaseImage>
            </PropertyGroup>
          </Target>

          <Target Name="ComputeOpenShiftContainerConfig" BeforeTargets="ComputeContainerConfig">

            <Error Condition="'$(OpenShiftImageName)' == ''" Text="'OpenShiftImageName' is not set." />
            <Error Condition="'$(OpenShiftInternalRegistry)' == ''" Text="'OpenShiftInternalRegistry' is not set." />
            <Error Condition="'$(OpenShiftCurrentNamespace)' == ''" Text="'OpenShiftCurrentNamespace' is not set." />

            <!-- Expand OpenShiftImageName, using OpenShiftInternalRegistry and OpenShiftCurrentNamespace. -->
            <PropertyGroup Condition="$(OpenShiftImageName.IndexOf('.')) == -1 Or $(OpenShiftImageName.IndexOf('.')) &gt; $(OpenShiftImageName.IndexOf('/'))">
              <OpenShiftImageName Condition="$(OpenShiftImageName.IndexOf('/')) == -1">$(OpenShiftCurrentNamespace)/$(OpenShiftImageName)</OpenShiftImageName>
              <OpenShiftImageName>$(OpenShiftInternalRegistry)/$(OpenShiftImageName)</OpenShiftImageName>
            </PropertyGroup>

            <!-- Set SDK container tooling properties based on OpenShiftImageName. -->
            <PropertyGroup>
              <ContainerRegistry>$(OpenShiftImageName.Substring(0, $(OpenShiftImageName.IndexOf('/'))))</ContainerRegistry>
              <ContainerRepository>$(OpenShiftImageName.Substring($([MSBuild]::Add($(OpenShiftImageName.IndexOf('/')), 1))))</ContainerRepository>
              <ContainerImageTag>latest</ContainerImageTag>
              <ContainerImageTag Condition="$(ContainerRepository.Contains(':'))">$(ContainerRepository.Substring($([MSBuild]::Add($(ContainerRepository.IndexOf(':')), 1))))</ContainerImageTag>
              <ContainerRepository Condition="$(ContainerRepository.Contains(':'))">$(ContainerRepository.Substring(0, $(ContainerRepository.LastIndexOf(':'))))</ContainerRepository>
            </PropertyGroup>
          </Target>
        </Project>
        EOF

        if [[ "${DOTNETCONFIG_DIRECTORY_BOUND}" == "true" ]] && [[ -f "${DOTNETCONFIG_DIRECTORY_PATH}/setup" ]]; then
          source "${DOTNETCONFIG_DIRECTORY_PATH}/setup"
        fi

        export CustomBeforeDirectoryBuildProps="/tmp/CustomBeforeDirectoryBuildProps.props"
        cat >"${CustomBeforeDirectoryBuildProps}" <<'EOF'
        <Project>
          <PropertyGroup Condition="'$(PublishProfile)' == 'OpenShiftContainer'">
            <PublishProfileFullPath>/tmp/OpenShiftContainer.pubxml</PublishProfileFullPath>
          </PropertyGroup>

          <Import Project="$(DOTNETCONFIG_DIRECTORY_PATH)/Build.props" Condition="'$(DOTNETCONFIG_DIRECTORY_BOUND)' == 'true' And Exists('$(DOTNETCONFIG_DIRECTORY_PATH)/Build.props')" />
        </Project>
        EOF

        exec {STDOUT_FD}</dev/stdout # workaround https://github.com/dotnet/msbuild/issues/9617.
        dotnet publish --getProperty:GeneratedContainerDigest --getProperty:ContainerRegistry --getProperty:ContainerRepository \
                       "/flp:logfile=/proc/self/fd/${STDOUT_FD};v=$(params.VERBOSITY)" \
                       /p:PublishProfile=OpenShiftContainer "/p:OpenShiftImageName=$(params.IMAGE_NAME)" "$(params.PROJECT)" \
                       >/tmp/proj-eval

        EVALUATION=$(cat /tmp/proj-eval)
        IMAGE_DIGEST=$(echo "$EVALUATION"  | grep "GeneratedContainerDigest" | awk -F'"' '{print $4}')
        IMAGE_REGISTRY=$(echo "$EVALUATION"  | grep "ContainerRegistry" | awk -F'"' '{print $4}')
        IMAGE_REPOSITORY=$(echo "$EVALUATION"  | grep "ContainerRepository" | awk -F'"' '{print $4}')

        echo "${IMAGE_DIGEST}" >/tekton/results/IMAGE_DIGEST
        echo "${IMAGE_REGISTRY}/${IMAGE_REPOSITORY}@${IMAGE_DIGEST}" >/tekton/results/IMAGE
